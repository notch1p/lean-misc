\documentclass{beamer}
\usepackage{tikz}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{fontspec}
\usepackage{minted}
\newmintinline[lean]{lean4}{bgcolor=white}
\newminted[leancode]{lean4}{fontsize=\footnotesize}
\usemintedstyle{tango}  % a nice, colorful theme
\setmonofont{Victor Mono}[Contextuals=Alternate]
\usetheme{CambridgeUS}
\usecolortheme{dove}
\usefonttheme{serif}

\DeclareMathOperator{\op}{\mathsf{op}}



\title{Folding in Parallel}
\subtitle{\textit{manually}}
\date{\today}
\author{notch1p}

\begin{document}
\frame{\titlepage}
\section{intro: fold vs.\ reduce}
\subsection{sequential vs.\ parallel}
\begin{frame}
    \frametitle{fold\{l,r\}}
    \begin{itemize}
        \item \textsf{foldl}: \ $(\alpha\to\beta\to\alpha)\to\alpha\to[\beta]\to\alpha$
        \item \textsf{foldr}: \ $(\alpha\to\beta\to\beta)\to\alpha\to[\alpha]\to\beta$
    \end{itemize}

    Examples:

    \begin{align*}
        \mathsf{foldl} & \ (\cdot + \cdot)\ 0\ \iota.4 &  & = 10 \\
        \mathsf{foldr} & \quad \ldots                  &  & = 10
    \end{align*}

\end{frame}

\begin{frame}
    \frametitle{how do they look?}
    \begin{align*}
        \mathsf{foldl} & \ (\cdot + \cdot)\ 0\ \iota.4 &  & \iff (((0 + 1) + 2) + 3) + 4 \\
        \mathsf{foldr} & \quad \ldots                  &  & \iff 1 + (2 + (3 + (4 + 0)))
    \end{align*}
    \begin{figure}[h]
        \subfloat[foldl]{
            \begin{tikzpicture}[level distance=.8cm, sibling distance=.8cm]
                \node {+}
                child {node {+}
                        child {node {+}
                                child {node {+}
                                        child {node {0}}
                                        child {node {1}}
                                    }
                                child {node {2}}
                            }
                        child {node {3}}
                    }
                child {node {4}};
            \end{tikzpicture}
        }\hspace{3cm}
        \subfloat[foldr]{
            \begin{tikzpicture}[level distance=.8cm, sibling distance=.8cm]
                \node {+}
                child {node {1}}
                child {node {+}
                        child {node {2}}
                        child {node {+}
                                child {node {3}}
                                child {node {+}
                                        child {node {4}}
                                        child {node {0}}
                                    }
                            }
                    };
            \end{tikzpicture}
        }
    \end{figure}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Sequential BAD}
    Compare:
    \begin{enumerate}
        \item $(((0 + 1) + 2) + 3) + 4$\hspace{1cm}\textbf{sequential}\hfill $O(\log n)$
        \item $(0 + 1) + (2 + 3 + 4)$\hphantom{()}\hspace{1cm}\textbf{parallel}\hfill $\Omega(\log n), O(\log n)$
    \end{enumerate}
    In other words, we would like to insert $+$ between elements.

    Languages like APL/J already do this:
    \mint[fontsize=\footnotesize]{j}|(+/ % #) 1 2 3 4 5 NB. 3. uses implicit fork.|
    Consider a more general case:
    \begin{equation*}
        ((a \op b) \op c) \op d \overset{?}{=} (a \op b) \op (c \op d)
    \end{equation*}
    When does the equation hold?
\end{frame}
\subsection{monoid reduce}
\begin{frame}
    \frametitle{monoid}
    $\op: S\to S\to S$ must satisfy $\forall a,b,c,e\in S$,
    \begin{align*}
        (a \op b) \op c & = a \op (b \op c) \tag*{Associativity}, \\
        a \op i         & = i \op a = a \tag*{Identity}.
    \end{align*}
    \begin{itemize}
        \item \textsf{Monoid}: A (carrier) set with an associative binary operation $\op$ and a unit element.
    \end{itemize}

\end{frame}
\begin{frame}[fragile]
    \frametitle{reduce}
    In other words,

    \begin{leancode}
        class Monoid (α: Type) where
        zero: α
        op: α -> α -> α
    \end{leancode}

    e.g.\ for $+$,

    \begin{leancode}
        instance m_nat_add : Monoid Nat := ⟨0, (· + ·)⟩
    \end{leancode}

    \textsf{reduce}: A fold-like operation that reduces over a monoid. We expect
    \begin{align*}
        \mathsf{reduce} & \ ::\ \alpha      &  & \Rightarrow \textsf{Monoid}\ \alpha \to [\alpha] \to \alpha, \\
        \mathsf{reduce} & \ m\ \mathsf{nil} &  & \equiv m.\mathsf{zero},                                      \\
        \mathsf{reduce} & \ m\ [x]          &  & \equiv [x].
    \end{align*}
    Then summing over $\iota.4$ would be
    \begin{equation*}
        \mathsf{reduce}\ \langle 0,(\cdot + \cdot)\rangle\ [1,2,3,4] \equiv 1 + 2 + 3 + 4
    \end{equation*}
    $+$ in some languages (e.g. CL) is already Monoidic and their implementation of reduce takes advantages from it.
\end{frame}
\begin{frame}[fragile]
    Sequential version of \textsf{reduce}:
    \begin{leancode}
        def reduce [m: Monoid α] (xs: List α): α :=
        match xs with
        | [] => Monoid.zero
        | [x] => x
        | x::xs => Monoid.op x (reduce xs)
    \end{leancode}
    How about parallel?
    Split list to smaller list:
    \begin{leancode}
        class ListSlice (α : Type) where
        l: List α
        start: Nat
        finish: Nat
    \end{leancode}
\end{frame}
\begin{frame}[fragile]
    \frametitle{parallel reduce}
    Parallel:
    \begin{leancode}
        partial def parreduce [Inhabited α] (m : Monoid α) (xs : ListSlice α) : α :=
        match xs.finish + 1 - xs.start with
        | 0 => m.zero
        | 1 => xs.l.get! xs.start
        | 2 => m.op (xs.l.get! xs.start) (xs.l.get! (xs.start + 1))
        | 3 =>
        m.op
        (m.op (xs.l.get! xs.start) (xs.l.get! (xs.start + 1)))
        (xs.l.get! (xs.start + 2))
        | n + 4 =>
        let n' := (n + 4) / 2
        let first_half := {xs with finish := xs.start + n' - 1}
        let second_half := {xs with start := xs.start + n'}
        m.op
        (parreduce m first_half)
        (parreduce m second_half)
    \end{leancode}
    \textbf{No data dependency i.e. Invocations can be done in parallel.}
\end{frame}
\section{folding with reduce}
\subsection{generic, yet of little practical use}
\begin{frame}[fragile]
    \frametitle{compose monoid}
    Consider \mintinline[fontsize=\footnotesize]{cl}{(foldr #'- 0 (iota 4)) ; => ((1- (2- (3- (4- x)))) 0)},

    \texttt{(n-)} can be seen as a function. (CL does have \texttt{1- 1+}) Or generally,
    \begin{equation*}
        \mathsf{foldr}\ (\textsf{n-})\ z\ l\ \iota.n = (\textsf{n-})^{\circ n}\ z
    \end{equation*}
    \begin{itemize}
        \item how about constructing monoid from function composition\dots
    \end{itemize}
    Obviously,
    \begin{align*}
        (f \circ g) \circ h       & = f \circ (g \circ h)           \\
        \operatorname{id} \circ f & = f \circ \operatorname{id} = f
    \end{align*}
    Thus we obtain
    \mint[fontsize=\footnotesize]{lean4}|instance compose_monoid : Monoid (α -> α) :=  ⟨id, λ f g x => f (g x)⟩|
    Key idea: $\circ$ is associative.
\end{frame}
\begin{frame}[fragile]
    But how do we make \texttt{(n-)}, or generally, a bivariate function with its lvalue pre-filled?
    \begin{itemize}
        \item \textit{Partial Application}. Very easy in a curried language.
    \end{itemize}
    Now \textsf{foldr} would be
    \begin{leancode}
        def foldr (f: α -> β -> β) (init: β) (xs: List α): β :=
        List.map f xs |> reduce compose_monoid <| init
    \end{leancode}
    \textsf{foldl} is tricky:
    \mint[fontsize=\footnotesize]{cl}|(foldl #'- 0 (iota 4)) ; => ((-4 (-3 (-2 (-1 x)))) 0).|
    since it's \mintinline[fontsize=\footnotesize]{cl}{(f init xs_i)} instead of \mintinline[fontsize=\footnotesize]{cl}{(f xs_i init)}. Meaning we'll pre-fill rvalue without evaluating the whole call.
    \begin{leancode}
        def fold_left (f: α -> β -> α) (init: α) (xs : List β): α :=
        xs.map (λ x => λ init => f init x) |> reduce compose_monoid <| init
    \end{leancode}
    
    \begin{itemize}
        \item A practical implementation of \textsf{mapReduce} is to fuse \textsf{map} and \textsf{reduce} together. Much efficient than what we have now.
        \item We write them separately for sake of clarity.
    \end{itemize}
    
\end{frame}
\begin{frame}
    \frametitle{Performance: {\fontspec{Symbola}\char"1F4A9}}
    A length of $n$ list yields a composition of $n$ closures.

    A closure takes up several words of heap space.

    Heap be like: {\fontspec{Symbola}\char"1F480}

\end{frame}
\section{finding monoid}
To do this efficiently: 
\begin{itemize}
    \item factor out the folding function $f$ in terms of
\end{itemize}
\begin{equation*}
    f\ z\ l = op\ z\ (g\ l)
\end{equation*}
\begin{itemize}
    \item requires ingenuity
\end{itemize}
\end{document}